% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/marginalise.R
\name{marginalisation}
\alias{marginalisation}
\alias{marginalise}
\alias{discrete_marginalisation}
\title{direct marginalisation of random variables}
\usage{
marginalise(fun, variable, method, ...)

discrete_marginalisation(values)
}
\arguments{
\item{fun}{an R function to integrate with respect to the random variable.
The first argument must be a greta array for the random variable, any
subsequent arguments must passed in via the \dots argument.}

\item{variable}{a variable greta array with a distribution, representing the
random variable to marginalise}

\item{method}{a \code{marginaliser} object giving the method for carrying out
the marginalisation}

\item{\dots}{named greta arrays to be passed to \code{fun}}

\item{values}{an R vector giving values at which to evaluate the function for a
discrete marginalisation}
}
\value{
\code{discrete_marginalisation} - a \code{marginaliser} object that
  can be passed to \code{marginalise}.
}
\description{
Inference on many statistical models requires marginalisation of
  (ie. integration of functions over) random variables. In addition to
  general purpose marginalisation methods like MCMC that act on an entire
  model, it is often useful to directly marginalise a single random variable
  within a larger model; e.g. for random variables where marginalisation by
  MCMC is inefficient, impossible, or when an approximate marginalisation is
  substantially more efficient. \code{marginalise()} performs direct
  marginalisation within a greta model, using one of the available marginalisation methods.
}
\details{
The code in \code{fun} must define at least one distribution over
  data (ie. a model likelihood), and cannot create any new variables. Any
  variables must be created outide this function, and passed in via the \dots
  argument.

\code{discrete_marginalisation} can only be used with discrete
  probability distributions, e.g. those defined with \code{poisson()} and
  \code{binomial()}. For discrete distributions with finite support (such as
  \code{bernoulli()}) the marginalisation will be exact, so long as
  \code{values} includes all possible values of the variable. For discrete
  distributions with non-finite support (such as \code{poisson()}, which has
  no upper bound), the marginalisation can only ever be approximate. However
  if \code{values} cover a range of values with sufficiently high support in
  the distribution, that approximation error will be minimal.
}
\examples{
\dontrun{
# marginalise a discrete random variable and carry out HMC on the
# continouous variables:
y <- rnorm(100)

lambda <- lognormal(0, 1)
theta <- normal(0, 1)
sd <- lognormal(0, 1)

# if discrete variables could be sampled by MCMC in greta,
# we would be able to simply do:
#   n <- poisson(lambda)
#   mu <- theta ^ n
#   distribution(y) <- normal(mu, sd)

# the function to marginalise over - the variable to marginalise
# must be first, others must be passed to marginalise()
fun <- function (n, theta, mu, sd) {
  mu <- theta ^ n
  distribution(y) <- normal(mu, sd)
}

# integrate the function values w.r.t. the poisson distribution
marginalise(fun,
            poisson(lambda),
            method = discrete_marginalisation(values = 0:10),
            theta = theta,
            mu = mu,
            sd = sd)

m <- model(lambda)
draws <- mcmc(m, hmc())
}
}
